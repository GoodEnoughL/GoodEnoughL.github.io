{"pages":[],"posts":[{"title":"JavaScript函数polyfill系列","text":"本文章通过重写JavaScript各个关键函数，增进自己对JavaScript的理解。 1.call,apply,bind函数12345678910111213141516171819202122232425262728Function.prototype.myCall = function(obj){ const func = this let args = Array.from(arguments) args.shift() const key = Symbol() obj[key] = func const result = obj[key](...args) delete obj[key] return result}//apply函数除了对于参数的处理外,与上等同Function.prototype.bind = function(){ let thisFun = this //获得绑定对象 let targetObj = arguments[0] //获得原来的参数 let args = Array.prototype.slice.call(arguments,1) if(typeof thisFun !== 'function'){ throw new TypeError('The first argument is not a function!') } return function(){ //获得新传入的参数 let args2 = Array.prototype.slice.call(arguments) //返回新函数需求的结果 return thisFun.apply(targetObj,[...args,...args2]) }} 参考文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof 2.new函数12345678910111213let _new = function(fn,_args){ let args = [].slice.call(arguments) let cons = args.shift() //B=Object.create(A)返回的是一个空的对象，只不过它的_proto_指向了A,也就是说B的所有属性和方法都是从原型链上找A要的，如果用hasOwnProperty去查，那么它什么都没有 obj = Object.create(cons.prototype) cons.apply(obj,args) return obj}Person.prototype.toA = ()=&gt;{return 5}function Person(age){this.age = age}let p = _new( Person,10) 参考文档：https://wangdoc.com/javascript/oop/new.html#new-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86 3.Object.create函数123456789Object.create2 = function(obj){ function F(){} F.prototype = obj return new F()}Person.prototype.toA = ()=&gt;{return 5}function Person(age){this.age = age}let p = new( Person,10)let o = Object.create2(p)","link":"/2021/04/28/JavaScript%E5%87%BD%E6%95%B0polyfill%E7%B3%BB%E5%88%97/"},{"title":"Promise重写","text":"本系列中的函数都经过测试可以使用，如有错漏，请留言帮助修改。 Promise.all1234567891011121314151617181920212223242526272829303132Promise.myAll2 = function(arr){ let result = new Array(arr.length) let count = 0 return new Promise(function(resolve,reject){ arr.forEach((value,index)=&gt;{ Promise.resolve(arr[index]).then((value)=&gt;{ count++ result[index] =value if(count === arr.length) return resolve(result) },(reason)=&gt;{ return reject(reason) }) }) })}let a = new Promise((reslove,reject)=&gt;{ reslove(1)})let b = new Promise((reslove,reject)=&gt;{ reslove(2)})let c = new Promise((reslove,reject)=&gt;{ reject(3)})Promise.myAll2([a,b,c]).then((value)=&gt;{ console.log(value)},(reason)=&gt;{ console.log(reason)}) Promise.race1234567891011Promise.myRace = function(arr){ return new Promise(function(resolve,reject){ arr.forEach((value,index)=&gt;{ Promise.resolve(arr[index]).then((value)=&gt;{ return resolve(value) },(reason)=&gt;{ return reject(reason) }) }) })}","link":"/2021/04/27/Promise%E9%87%8D%E5%86%99/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/04/27/hello-world/"},{"title":"增进JavaScript理解的题目","text":"JavaScript代码掌握不够，特开此文练习JavaScript技巧 一、JavaScript技巧篇1.编写一个parseNum函数将变量内的number数据类型变为对应string示例： 123456789101112131415161718//示例var obj = { a:1, b:{ c:2, d:3, e:[4,5,6] }}var b = parseNum(obj)// b = {// a:'1',// b:{// c:'2',// d:'3',// e:['4','5','6']// }// } 答案： 123456789101112131415161718function parseNum(obj){ if(typeof obj === 'number'){ return obj.toString() } if(typeof obj === 'object'){ if(!obj &amp;&amp; typeof obj !==&quot;undefined&quot; &amp;&amp; obj !== 0) return obj else{ for(var i in obj){ if(obj.hasOwnProperty(i)){ obj[i] = parseNum(obj[i]) } } return obj } } return obj} 解析：本题考察的是数据类型的检测，使用typeof函数获得obj的名称，然后进行字符串比较。在这个过程中，需要注意typeof null、Array、object都会得到object使用Array.isArray()以及(!obj &amp;&amp; obj!==0 &amp;&amp; typeof obj !== ‘undefined’)分辨Array和Null本问题参考文献：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeofhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof 2.编写一个函数mRead读取数组，要求记忆每次读取的进度案例： 123456var c = [2,3,4,5,6,7,8,9,10]var rea = mRead(c)rea(1) //[2]rea(1) //[3]rea(2) //[4,5]rea(-1.5) //[6] 答案： 12345678910111213function mRead(line){ var seen; if(typeof seen === 'undefined'){ seen = 0; } return function mRead2(n){ if(n &lt;1 || n%1!==0) n = 1 var result = line.slice(seen,seen+n) seen += n return result }} 3.编写一个函数，要求不能声明任何外部函数；奇数次调用该函数时输出1，偶数次调用该函数输出2123456789101112let a = (function(){ let count = 1 return function(){ if(count % 2 !== 0){ console.log(1) } else{ console.log(2) } count++ }})() 4.编写一个函数，返回指定位数的随机字符串1234567891011121314151617function randomString(str_len){ var ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; ALPHABET += 'abcdefghijklmnopqrstuvwxyz'; ALPHABET += '0123456789-_'; var str = ''; let index = 0 for(let i = 0;i &lt; str_len;i++){ let a = Math.random() * ALPHABET.length index = Math.floor(a) str += ALPHABET[index] } return str}let b= randomString(5)console.log(b) 5.编写一个函数，要求实现add(1,2),add(1,2)(3),add(1,2)(23)(5)等不定参数的加减123456789101112131415function add2(){ let _args = Array.prototype.slice.call(arguments) let _add2 = function(){ _args.push(...arguments) return _add2 } _add2.toString = function(){ let b = _args.reduce((x,y)=&gt;{ return x+y }) return b } return _add2} 6.编写一个函数，对字符串中相应重复字符计数拼接后返回例子： 12let str = 'aabbbcdddeeeeee'let b = transformStr(str)//a2b3c1d3e6 1234567891011let str = 'aabbbcdddeeeeee'function transformStr(str){ let line = str.match(/(\\w)\\1*/g) let result = &quot;&quot; for(let i = 0;i &lt; line.length;i++){ result += line[i][0] result += line[i].length } return result}let b = transformStr(str) 7.前K个高频单词例子： 给一非空的单词列表，返回前 k 个出现次数最多的单词。 返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。 答案： 1234567891011121314var topKFrequent = function(words, k) { let m = new Map() for(let i of words){ m.set(i,(m.get(i) || 0) + 1) } let result = [] for(let k of m.keys()){ result.push(k) } result.sort((a, b) =&gt; { return m.get(a)===m.get(b)?a.localeCompare(b):m.get(b)-m.get(a) }) return result.slice(0,k)}; 8.防抖与节流函数考虑了函数执行时 this 指针以及参数的问题 1234567891011121314151617181920212223242526function debounce(fn,delay){ let timer return function(){ if(timer){ clearTimeout(timer) } timer = setTimeout(function(){ fn.call(this.arguments) },delay) }}function throttle(fn,delay){ let flag = false return function(){ if(flag){ return } flag = true setTimeout(function(){ fn.call(this,arguments) flag = false },delay) }}window.onscroll = debounce(function(){console.log(this)},1000)window.onscroll = throttle(function(){console.log(this)},1000) 9.处理url的能力，提供parse、stringify方法做参数处理10.重写 flat 函数123456789101112function myFlat(arr){ let path = [] for(let i of arr){ if(Array.isArray(i)){ path.push(...myFlat(i)) } else { path.push(i) } } return path} 11.Json转化为树状数组给定一个一维数组，将该数组转换成树状结构的根节点数组，并返回转换后的json字符串 请在代码编辑器中实现以下函数 function transformToTree(nodeList) {} 请注意： 1、子节点通过parentId属性关联父节点 2、子节点存入父节点的children属性中，children值类型为数组 3、parentId可能为空或指向不存在的父节点，在这种情况下，当前节点作为根节点 如： 转换前的一维数组 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[ { id: '3', parentId: '1' }, { id: '1', parentId: '' }, { id: '2', parentId: '4' }]转换后的json结构[ { &quot;id&quot;: &quot;1&quot;, &quot;parentId&quot;: &quot;&quot;, &quot;children&quot;: [ { &quot;id&quot;: &quot;3&quot;, &quot;parentId&quot;: &quot;1&quot; } ] }, { &quot;id&quot;: &quot;2&quot;, &quot;parentId&quot;: &quot;4&quot; }]// 最终输出的json字符串[{&quot;id&quot;:&quot;1&quot;,&quot;parentId&quot;:&quot;&quot;,&quot;children&quot;:[{&quot;id&quot;:&quot;3&quot;,&quot;parentId&quot;:&quot;1&quot;}]},{&quot;id&quot;:&quot;2&quot;,&quot;parentId&quot;:&quot;4&quot;}]function translateDataToTree(data, parentId = '') { let tree = []; let temp; data.forEach((item, index) =&gt; { if (data[index].parentId == parentId) { let obj = data[index]; temp = translateDataToTree(data, data[index].id); if (temp.length &gt; 0) { obj.children = temp; } tree.push(obj); } }) return tree;} 12.对数字字符串进行千分位处理1234567891011121314function formatNumber(num){ return num.toString().split('').reduce((prev,next,index)=&gt;{ return ((index%3) ? prev :(prev+','))+next })}function formatNumber(num){ return (num.toString()).replace(/\\B(?=(\\d{3})+$)/g,',')}function formatNumber(num){ let [integer, decimal] = String(num).split('.'); integer = integer.replace(/\\d{1,3}(?=(\\d{3})+$)/g, '$&amp;,'); decimal = decimal ? `.${decimal}` : ''; return integer + decimal;} 13.红绿灯循环5次1234567891011121314151617181920212223242526let red = () =&gt; console.log('red')let yellow = () =&gt; console.log('yellow')let green = () =&gt; console.log('green')function print(delay, callback) { return new Promise((resolve, reject) =&gt; { callback(); setTimeout(() =&gt; { resolve(); }, delay); })}function step(count) { Promise.resolve() .then(() =&gt; print(1000, red)) .then(() =&gt; print(2000, yellow)) .then(() =&gt; print(3000, green)) .then(() =&gt; { if (count &gt; 1) { return step(count - 1) } })}step(5) 14.完成深拷贝以及浅拷贝函数1234567891011121314151617181920212223242526//浅拷贝函数function clone(target) { let cloneTarget = {}; for (const key in target) { cloneTarget[key] = target[key]; } return cloneTarget;};//深拷贝函数function clone(target,weakMap = new WeakMap()){ if(typeof target === Object){ let cloneTarget = Array.isArray(target) ? [] : {} if(weakMap.has(target)){ return weakMap.get(target) } weakMap.set(target,cloneTarget) for(let i in target){ cloneTarget[i] = clone(target[i]) } return cloneTarget } else { return target }} 参考文献：https://juejin.cn/post/6844903929705136141#heading-3","link":"/2021/04/28/%E5%A2%9E%E8%BF%9BJavaScript%E7%90%86%E8%A7%A3%E7%9A%84%E9%A2%98%E7%9B%AE/"},{"title":"gitalk 403问题解决过程","text":"前言​ 在搭建Hexo博客的评论系统时遇到一些麻烦，从此引发了一系列关于解决问题方法论的思考。 ​ 本文章并不注重于问题本身的解决，而是思考在解决问题过程中的思想，希望能对我们面对新前端技术栈、解决前端问题时的思路做一下梳理，整理一下解决问题的方法。 启程​ 在使用gitalk过程中，出现了一个403错误。 ​ 行吧，作为一位资深面向百度前端开发工程师，我们先来百度一个试试。我们获得了以下一个博客：https://cuiqingcai.com/30010.html 文章解决方法没啥好说的，大意是说gitalk本身是使用cors-anywhere解决本身的跨域问题，现在cors-anywhere挂了，要重新找一个代理跨域。不过这位大佬的解决问题思路和方法论非常值得我学习： ​ 使用谷歌搜索而不是百度 ​ 遇到网络问题查Chrome的network面板，查看请求头和请求返回等等 ​ 查相应库的readme ​ 到遇到问题的github库查issue(以前我都不知道issue这么用的) ​ 总有一天，我们遇到的问题是新出现的(cors-anywhere是2021-1-31后不再接受代理的)，没有人碰到过。这个时候就要我们自己实地解决一个问题了。学习这种大佬解决问题的思路的确能帮助我们改变遇事不决就百度，然后遇到五花八门重复抄袭不知名答案的窘境。 过程​ 上博客中给了一个新的代理地址，尝试之后发现这个新代理也已经无法使用。查了一下跨域的解决方法，加上手头上正好有一台服务器，遂决定自己做一个反向代理，解决这个跨域问题。 ​ 具体关于跨域是什么，如何解决跨域等问题本文就不再赘述，因为那不是本文重点，读者可以自行搜索了解。 陌生阶段。​ 安装Nginx、打开firewalld的80端口、配置nginx. conf，最后，chrome浏览器打开试一试——相应时间过长…这个过程持续了一段时间，我处于对nginx十分陌生的阶段。因为我是直接抄网上的配置方案，我一开始以为是nginx配置错误，将nginx英文文档大致看了一遍，发现自己的配置参数符合文档要求，没有错误。之后一直没有解决，有一点抓狂，后来遇事不决就重启，成功了…经过查文档，发现需要reload nginx使配置生效！这一个阶段我认为可以参考网上现成的案例以及官方文档快速了解该技术栈是如何使用的，可以加深印象并快速进入它的构建。 参考文档：https://juejin.cn/post/6844904144235413512#heading-10 使用阶段​ 在这个阶段，我已经大致明白nginx使用方式，妄图通过自己的思考配置反向代理。事实证明这是错误的，我虽然对nginx各个参数有大致的了解，但我不知道如何架构配置它们，导致我的配置常常出现错漏。这个时候，我还是需要参考网络上的先例，进行配置。 ​ 但是完全参考网上一个成功案例的代码，我却还是失败了。经过长时间的摸排以及一点运气，我发现了一些原因： ​ 我的博客是托管在github上，使用https协议；nginx服务器使用的是http协议。由于安全策略，并不允许在https网站上调用http接口。接下来我在腾讯云注册域名、申请了CA证书，将nginx服务器升级为https协议。 ​ 都完成后遇到问题： ​ 我应该再服nginx务器加了请求头Access-Control-Allow-Origin的，但是这里没有反应，我们试试直接请求： ​ 对比我们之前的请求： ​ 也就是说，这个请求没有在nginx匹配成功。nginx在这里对于http和https使用了不同的匹配。经过查看chrome的network，我们发现http请求了服务器的80端口，https请求了443安全接口。因此导致它们相同地址的匹配不一致。在这种情况下我为了快速实现，直接在nginx443端口的配置中加入了反向代理的配置，终于实现了跨域代理！ ​ nginx配置如下： 1234567891011121314151617181920server { charset utf8; listen 443 ssl; server_name www.betterhgl.xyz; ssl_certificate 1_www.betterhgl.xyz_bundle.crt; ssl_certificate_key 2_www.betterhgl.xyz.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location = /login/oauth/access_token { add_header Access-Control-Allow-Origin 'https://goodenoughl.github.io'; add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS'; add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With, If-Modified-Since,Cache-Control,Content-Type,Authorization'; if ($request_method = 'OPTIONS') { return 204; } proxy_pass https://github.com; } } 总结​ 本文章主题是梳理我解决问题的方式，问题的解决本身还是次要的。我们应明确自己在遇到问题时如何应对，得到一套应对流程，帮助我以后面对各样的问题。结果如下： 在初入一个技术栈时学习前人的做法 学习前人做法同时以技术文档作为参考，明晰解决思路 应拓展前端学习广度，如这次跨域问题的基本理论需要明晰。具有知识广度有助于我们迅速挖掘其深度知识 应对前端工具如Chrome等寻找一个专门的训练，它具有复杂的使用技巧，而我们一直像傻瓜一样使用它 遇到问题可以多看文档和相关issue 我们在面对前端技术问题时，应有相应的思维，有时候百度并不能解决所有问题，这种思维正是我们日后解决问题的方向。 参考文档： https://www.qiansw.com/solve-the-problem-of-using-gitalk-authorization-403.html https://blog.csdn.net/qq_40933913/article/details/107466445 http://nginx.org/en/docs/ https://github.com/Rob--W/cors-anywhere ​","link":"/2021/05/01/gitalk%20403%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%BF%87%E7%A8%8B/"},{"title":"Nginx反向代理搭建","text":"本文软件配置操作系统：CentOs7 Nginx版本：1.16.1 前端网站：Hexo框架搭建的博客 安装参考文档：https://juejin.cn/post/6844904144235413512#heading-10 注意事项1.nginx修改完配置需要reload，否则不会生效 2.前端网站和nginx服务器地址不一样，需要在nginx中配置为返回的response增加跨域有关的请求头，帮助前端浏览器识别到这个跨域已经被准许 3.我博客托管在github，使用的https协议，而nginx服务器使用的http协议，不能从https去请求http","link":"/2021/05/02/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E6%90%AD%E5%BB%BA/"},{"title":"shadowsocks使用方法","text":"参考文档：https://www.myzhangyi.com/study/ssserver.html https://blog.csdn.net/x356982611/article/details/90414752 http://c.biancheng.net/view/1023.html 完全按照以下博客，即可完成shadowsocks的搭建： https://www.4spaces.org/install-shadowsocks-on-centos-7/ trpjan服务器： https://www.v2rayssr.com/trojan-2.html https://www.codeob.com/?p=212 https://trojan123.com/index.php/2020/03/29/trojan-ios-zidong-peizhi/","link":"/2021/05/02/shadowsocks%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"},{"title":"《深入浅出Webpack》读书感想-如何写一个技术手册","text":"前言​ 本文章为对《深入浅出Webpack》一书的读后感想，本文章主要内容为对《深入浅出Webpack》写作手法进行解析，对Webpack的解析将在第二篇博客中体现。 ​ 你能收获什么？ ​ 本文章是对技术手册以及书籍写作手法的解析，掌握这部分，你就能选择合适的方式去阅读文档，揣摩作者写作时费尽心血时的心理过程，妈妈再也不用担心我跪着看文档啦！另外，我们日常对自己思想的整理也会通过博客等形式产出，通过学习模仿优秀的写作手法，将对我们表达思想，乃至日常沟通时的结构性思维具有帮助。 ​ //(注释掉这一行)阅读《深入浅出Webpack》书籍以及本文章需要对CommonJs、AMD、ECMAScript2015中模块化以及前端工程化思想有一定了解。 开篇​ 一个好的文档手册应该是什么样的？ ​ 身为技术人员，无论是学习新知识、还是解决技术栈中遇到的问题，我们总是免不了和各种技术文档打交道。然而，相信大多数同学和我相似，学习一个新技术时，都曾经被暴雨倾盆般新概念、新术语打的焦头烂额。我不禁想问，到底怎么写才能迎合读者的需求呢，如何怎么样才能与用户沟通，让读者了解我的思想呢？ ​ 带着这个疑问，我将过去看过的不同类型技术文档、在不同时期看同一篇技术文档中思想的变化进行回忆，将遇到的技术文档大致分为2类： 字典型 引导型 ​ 字典型顾名思义类似于新华字典，它注重于全面地展现需要表达内容的每一个细节，我们通常不会一开始就把字典阅读一遍，但是当我们对该内容有一定了解、或是遇到问题，字典型技术手册就派上用场了。相信同学们都阅读的过阮一峰老师的《ES6 标准入门教程》以及《JavaScript 语言入门教程》，甚至Python等语言的官方文档都是这个类型，它们的共同点之一——十分详尽。当你刚开始接触这些新内容，你很容易便迷失在厚厚的书籍中。只有当你大致对新内容有一些了解，你遇到问题时，再回头阅读这些文档，你才会发现它有你需要的大多数答案，把它重新阅读一遍你能够更加体会到技术作者在创作这门技术时的思想以及过程。 ​ 引导型书籍，我们今天解析的这本《深入浅出Webpack》就使用的引导型手法。它的经典特征是制造一个矛盾，吸引读者跟着作者的思考方向走，在这个过程中将新技术解决的痛点展现给读者看。这种手法的好处是具有趣味性、吸引读者、并且更容易让读者体会思想而不是具体解决方法。 ​ 明确了以上两点，那么我们写一个文档就要明白自己的定位在哪里，明确用户需求是我们有效产出的前提。 参考文献： 《深入浅出Webpack》：http://webpack.wuhaolin.cn/2%E9%85%8D%E7%BD%AE/2-4Resolve.html","link":"/2021/05/18/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAWebpack%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%84%9F%E6%83%B3/"},{"title":"ES6的Generator、Symbol、Promise、Async的情感大戏","text":"引言​ 该博客对ES6语法中Generator、Promise、Async语法进行总结。 ​ 主要脉络是为什么有Generator，具体应用，它与Promise、Async的关系，注意事项。 ​ 有同学们问：generator语法日常用不到，可以使用 async、await，generator 教程篇幅长，它真的值得花费大量精力学习吗？ ​ 答案是：应该学习。我们在日常开发中常用的 async、await 实际上是 generator 的语法糖。generator 本身思想也有相当的参考意义，想进阶高级前端工程师，学习各个方案的思想是我们的必经之路。 ​ 本人才疏学浅，本博客中示例代码摘抄自阮一峰《ECMAScript 6 入门》，如有错漏敬请谅解。 Generator概述** ​ Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。 ​ Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 ​ 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 ​ 上面这段话引用自《ECMAScript 6 入门》，可能初看时不明所以，但是实际上写尽了Generator语法内涵。 ​ Generator的应用如下： ​ 异步操作的同步化表达 ​ 控制流管理 ​ 部署Iterator接口 ​ 作为数据 ​ Generator最核心的含义是状态机！ ​ Generator最核心的含义是状态机！ ​ Generator最核心的含义是状态机！ ​ ​ 以下引用知乎@dboy的比喻： ​ Async、Iterator利用这种状态机的特性。 Generator的应用1.部署Iterator接口​ 在ES6新增的语法中 for of 以及 for in 遍历器深入到我们项目中各个角落。 ​ 实际上，我们for of的每次循环都遵循Generator的规范 ​ 一个数据结构具有Symbol.iterator属性，并且该属性每次遍历返回符合规定的数据结构，那么我们就说这个数据结构是一个iterable的，我们可以使用for of遍历这个数据对象，因此，我们可以通过在对象上部署Symbol.iterator属性将它修改为可遍历的。 ​ 以下例子中我们手动实现了Symbol.iterator属性。 ​ 实际上，我们可以通过在目标数据结构上部署Generator，快速部署Iterator接口。 ​ 从这两个例子中我们能得知，iterator的遍历与Generator的状态机的属性是密不可分的。 2.异步操作的同步化表达​ 在ES5中发出异步请求，会出现回调地狱的问题，ES6在异步操作上做出的一个很大的努力就是可以将异步请求以同步的语法书写。 Generator​ 以下是Generator的异步写法，可以看到，这个异步操作最终转化为从上而下的代码，不需要再使用异步成功后的回调。但是这个写法有一个缺点：需要手动执行每一个next()函数。因此，我们在开发中不会使用这种异步调用方法。 Promise接下来是Promise的写法。Promise对于异步操作最经典的操作即是链式调用： ​ 由以上可以看到，Promise对于异步返回的结果一步步采用then操作，形成一条长的链条。Promise等异步操作完成后会自动执行后续操作，避免了Generator的尴尬境地。 Async/Await​ 那么，Promise 有没有改进的地方呢？当然有！成也链式传递，败也链式传递，一旦我们操作需要不断传递结果，那么Promise的链会非常长，书写不方便的同时也不便于了解它们中数据的流动逻辑，这个时候 ES7 为我们送来了异步操作的终极解决方案： Async/Await ​ ​ Async/Await 和 Generator 的写法很相似，也就是把 * 换成 Async ， yield 换成 await 。但是它是有自动执行器的，也就是说我们不需要像 Generator 一样手动调用 next() 函数，不如说Async/Await是Generator在异步领域的封装。现在，我们只需要像写同步代码一样写异步代码即可，我们终于可以说：解决了异步操作调用的代码复杂问题。 ​ 另外，可能有同学和之前的我一样有点疑惑：在异步方面有 Async/Await 了，我们还需要 Promise 吗？其实，Async 函数本身返回的就是一个 Promise ，Promise 本身的特性也在许多操作中使用。因此， Promise 仍然是我们需要掌握的重点。 Symbol杂谈​ 最后，让我们聊一聊Symbol这个数据类型。刚看到 symbol 时，我有点无法理解它，有以下原因： 网络上对于Symbol的讨论非常少 我们日常的项目开发中没有见过这个数据类型 ​ 在我通读《Symbol》这一章节后，我终于明白它的作用。symbol 用于在各个对象中部署一些非常重要的接口，例如我们上一节中提到的 symbol.iterator,我们平时看不到它是因为它封装到我们日常使用的各种便捷接口中。match 函数，replace 函数等等都由 symbol 部署，感兴趣的同学们可以阅读这一章节深入了解。它可能几乎不出现在我们日常项目开发，但是了解它对于我们了解 JavaScript 运行有相当的帮助，让我们在看文档出现该用法时不至于茫然不知所措。 结语​ 以上博客总结了 Symbol 、Generator 、Iterator 、Promise 、 Async/Await 间的关系，可能本博客不适合初学者入门，但是相信对于这些概念存在一些混乱的同学能起到一些梳理作用。","link":"/2021/07/08/ES6%E7%9A%84Generator%E8%AF%AD%E6%B3%95/"},{"title":"QianKun框架学习心得","text":"微前端简介​ 微前端是什么，为什么要有微前端，微前端解决了什么问题。知乎用户@kuitos，qiankun框架作者的文章https://zhuanlan.zhihu.com/p/95085796非常好的解释了这一点。 ​ 总的来说，微前端技术解决了我们前端时空方向的需求。在空间上，微前端做到了技术无关性，前端页面中不同子模块组合，每一个子模块可以由不同的部门维护，每个部门采用不同的技术栈，在协同时只需要在qiankun注入的生命周期中发送数据即可；在时间上，微前端由于技术无关性，因此5年前的技术也可以与最新技术协同运行，这将使我们很大程度上脱离远古代码的维护困扰。 Qiankun框架实践​ 接下来不需要什么原理，让我们直接上手一个项目看看它的威力。 ​ 在知乎与掘金上看到的实践都是基于庞大的企业项目，这对于我们初学者来说可能不方便了解其中内涵，因此我选用 Vue2 、jQuery 、 React16 作为技术栈实践qiankun框架。qiankun框架最经典的应用即是控制台，作者@kuitos也说过：让天下没有短命的控制台。现在，我们创建一个控制台来实践一下这句豪言。 ​ 主应用我们选用vue-admin-template作为基座，这是一个非常成熟的vue2后台管理界面，另外作者写了一系列教程，我们能非常快地上手它。第一个页面我们采用jQuery写一个幻灯片。","link":"/2021/07/14/QianKun%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97/"},{"title":"书法笔记(一)","text":"引言：​ 学习书法已经半年，进展及其缓慢，我将认真对待自己的问题，审视自己在书法乃至其他领域思想习惯上的不足。 全局：​ 未能认识到字的真态、字体的空间结构、重心。","link":"/2021/06/02/%E4%B9%A6%E6%B3%95%E7%AC%94%E8%AE%B0-%E4%B8%80/"},{"title":"彻底搞懂JavaScript正则表达式贪婪和非贪婪","text":"","link":"/2021/07/28/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82JavaScript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%B4%AA%E5%A9%AA%E5%92%8C%E9%9D%9E%E8%B4%AA%E5%A9%AA/"},{"title":"通过Github连接过程学习DNS","text":"在使用git push过程中出现 “ Failed to connect to github.com port 443: Timed out ”错误，网络搜索显示为本机代理问题。 在 Windows 下将 C:\\Users\\Administrator.gitconfig 文件中的 http.proxy 、https.proxy 字段删除即可恢复正常。 莫名其妙，这中间原理待后续研究连接 git 连接过程。","link":"/2021/07/29/%E9%80%9A%E8%BF%87Github%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%AD%A6%E4%B9%A0DNS/"},{"title":"校招前端学习","text":"前端问题良好答案： JS： JavaScript之隐式类型转换：https://www.cnblogs.com/wind-lanyan/p/8696382.html JavaScript中数组的22种方法：https://www.cnblogs.com/xiaohuochai/p/5682621.html JavaScript 的 this 原理是什么？：https://www.zhihu.com/question/353757734/answer/964557747 （Lucas HC）前端基础进阶（三）：变量对象详解：https://www.jianshu.com/p/330b1505e41dJavaScript之变量对象：https://zhuanlan.zhihu.com/p/46950377前端面试：谈谈 JS 垃圾回收机制：https://segmentfault.com/a/1190000018605776#comment-areaJS事件循环：https://www.jianshu.com/p/184988903562JavaScript常见的六种继承方式：https://segmentfault.com/a/1190000016708006前端基础进阶（十）：深入详解函数的柯里化：https://www.jianshu.com/p/5e1899fe7d6bJavaScript中的Reflect对象详解(ES6新特性)：****https://www.jb51.net/article/89087.htm理解 JavaScript 的 async/await：https://segmentfault.com/a/1190000007535316#comment-area正则表达式30分钟入门教程：https://deerchao.cn/tutorials/regex/regex.htm#grouping浅谈cookie，session和localStorage，sessionStorage的区别：https://segmentfault.com/a/119000001715515110分钟彻底搞懂Http的强制缓存和协商缓存：https://segmentfault.com/a/1190000016199807一文读懂 HTTP/2 特性：https://zhuanlan.zhihu.com/p/26559480【综合篇】Web前端性能优化原理问题：https://blog.csdn.net/qq_36232611/article/details/104057870什么是跨域？如何实现？：https://www.jianshu.com/p/f049ac7e2220 九种跨域方式实现原理（完整版）：https://segmentfault.com/a/1190000018017118什么是回流，什么是重绘，有什么区别？：https://www.jianshu.com/p/e081f9aa03fb浅谈js防抖和节流：https://segmentfault.com/a/1190000018428170前端安全系列（一）：如何防止XSS攻击？：https://segmentfault.com/a/1190000016551188前端性能优化 24 条建议（2020）：https://segmentfault.com/a/1190000022205291前端科普系列-CommonJS：不是前端却革命了前端：https://zhuanlan.zhihu.com/p/113009496箭头函数：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functionsJavaScript中如何判断undefined和null：https://www.jianshu.com/p/8dfc98b9d706Typescript教程：https://www.runoob.com/typescript/ts-basic-syntax.html图解 script 标签中的 async 和 defer 属性：https://juejin.cn/post/6894629999215640583#comment你不知道的 DOMContentLoaded：https://zhuanlan.zhihu.com/p/25876048DOMContentLoaded与load的区别:https://www.cnblogs.com/caizhenbo/p/6679478.htmlpolyfill:面试官：“你能手写一个 Promise 吗”：https://zhuanlan.zhihu.com/p/183801144核心内容 深入理解JSCore：https://tech.meituan.com/2018/08/23/deep-understanding-of-jscore.htmlcss篇 **30 分钟学会 Flex 布局:**https://zhuanlan.zhihu.com/p/25303493通过游戏来学习CSS的Flex布局:https://www.cnblogs.com/YooHoeh/p/10465730.html**Flex弹性盒子详解：从量变到质变的理解:**https://blog.csdn.net/Newbie___/article/details/107042630**详说css与预处理器（以及less、sass、stylus的区别）:**https://blog.csdn.net/ly2983068126/article/details/77737292**css垂直居中的8种方式总结:**https://www.jianshu.com/p/7bbc4860a45ccss经典布局——圣杯布局：https://blog.csdn.net/qq_38128179/article/details/86533976css3实现动画有几种方式？：https://segmentfault.com/a/1190000022540857CSS3 动画：https://www.jianshu.com/p/15f2adfbdad0vue篇VUE知识要点总结思维导图：https://blog.csdn.net/xyphf/article/details/83722848面试题：你能写一个Vue的双向数据绑定吗？：https://juejin.cn/post/6844903589278646285#commentvue插槽（slot）详解：https://zhuanlan.zhihu.com/p/114502325?from_voters_page=truevue核心之虚拟DOM(vdom)：https://www.jianshu.com/p/af0b398602bc【Vue原理】Diff - 白话版：https://zhuanlan.zhihu.com/p/81752104手写Vue-router核心原理，再也不怕面试官问我Vue-router原理:https://juejin.cn/post/6854573222231605256#heading-9通用篇 高性能利器：CDN我建议你好好学一下！:https://juejin.cn/post/7002781373014474759#heading-9CDN与DNS知识汇总: https://juejin.cn/post/6844903590662766599#commentpx、物理像素、rem、rpx的关系：https://www.jianshu.com/p/1b69f0df78f3?from=timeline网络篇 TCP的三次握手与四次挥手理解及面试题（很全面）：https://blog.csdn.net/qq_38950316/article/details/81087809 **TCP的拥塞控制（详解）:**https://blog.csdn.net/qq_41431406/article/details/97926927HTTP与HTTPS的区别，详细介绍：https://blog.csdn.net/qq_35642036/article/details/82788421数据结构与算法 代码随想录：https://programmercarl.com/面试官最喜爱的TopK问题算法详解：https://zhuanlan.zhihu.com/p/76734219：","link":"/2021/07/28/%E6%A0%A1%E6%8B%9B%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"},{"title":"JavaScript原型链问题详解","text":"前言​ 原型链中关于继承，引用对象都有 proto 属性、函数对象才有 prototype 属性的问题我们已经了解，在此不做赘述，本文将解答下列一些重点难点问题。 ​ Object.prototype 的 __proto__ 属性是一个访问器属性（一个getter函数和一个setter函数）, 暴露了通过它访问的对象的内部 [[Prototype]] (一个对象或 null)。 问题​ 1.为什么 Foo.prototype[‘proto‘] 指向 Object.prototype ? ​ A: Foo.prototype 是一个对象，，它由构造函数 function Object() 生成，因此指向 Object.prototype。Function.prototype 同理。 ​ 2.为什么 Object._ proto_ 指向 Function.prototype ? ​ A: Object 在此作为一个构造函数，可以使用 new Function() 构造，Object 在此作为 Function 的生成对象，因此 Object._ proto_ 指向 Function.prototype 。 ​ 3.为什么 Function._ proto_ === Function.prototype ​ A: 同1，Function 是一个构造函数，它的 proto 指向 Function.prototype ​ 4.Object.prototype 是一个对象，为什么 Object.prototype[‘proto‘] 不是指向 Object.prototype ? ​ A:本题存疑，目前得到的说法是设置为 null ，防止原型链查找时导致循环查找，该说法有一定可靠性。使用上图中的例子：对 f1 对象查找属性，如果无法找到，依次查找过程为： Foo.prototype -&gt; Object.prototype -&gt; Object.prototype[‘proto‘]。如果 Object.prototype[‘proto‘] === Object.prototype ,那么将永远循环。 题目练习123function People() {}let p = new People()const Animal = () =&gt; {} 请将下列内容相等的结果分组 123456789101112undefinednullFunction.prototype Object.prototypeObject.prototype['__proto__']Function.prototype['__proto__']People.prototypePeople['__proto__']Animal['__proto__']Animal.prototypep['__proto__'] 答案1234567undefinedFunction.prototype === People['__proto__'] === Animal['__proto__']Object.prototype === Function.prototype['__proto__']Object.prototype['__proto__'] === nullPeople.prototype === p['__proto__']Animal.prototype 注意警告: 当Object.prototype.__proto__ 已被大多数浏览器厂商所支持的今天，其存在和确切行为仅在ECMAScript 2015规范中被标准化为传统功能，以确保Web浏览器的兼容性。为了更好的支持，建议只使用 Object.getPrototypeOf()。","link":"/2021/09/09/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3/"},{"title":"举一反三！","text":"Vue 篇 单页面应用更新节点，但是不会向后端请求，为什么？ url，路由发生了什么？ hash模式、history模式为什么会有 ‘#’ 等等，它们真实原因到底是为什么，什么是它的兼容性？","link":"/2021/09/08/%E4%B8%BE%E4%B8%80%E5%8F%8D%E4%B8%89%EF%BC%81/"},{"title":"计算机网络原理知识整理","text":"数据链路层1.流量控制：https://www.cnblogs.com/PBDragon/p/14920433.html 2.动态分配信道 ALOHA协议、CSMA协议、CSMA/CD协议、CSMA/CA:https://www.cnblogs.com/PBDragon/p/14928547.html 3.通信 CSMA/CD工作原理:https://blog.csdn.net/CYKsky/article/details/43058607?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&amp;spm=1001.2101.3001.4242 网络层IP数据报格式详解:http://c.biancheng.net/view/6411.html 传输层1.TCP的拥塞控制（详解）:https://blog.csdn.net/qq_41431406/article/details/97926927 2.拥塞控制：https://www.cnblogs.com/5iedu/p/7260977.html 3.TCP滑动窗口机制深度剖析：http://c.biancheng.net/view/6427.html 4.TCP报文格式解析：http://c.biancheng.net/view/6441.html 应用层1.HTTP 协议入门：http://www.ruanyifeng.com/blog/2016/08/http.html","link":"/2021/09/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"title":"举一反三小课堂(一)、浏览器缓存机制","text":"","link":"/2021/09/16/%E4%B8%BE%E4%B8%80%E5%8F%8D%E4%B8%89%E5%B0%8F%E8%AF%BE%E5%A0%82-%E4%B8%80-%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"},{"title":"","text":"1.业务也很重要，做到高级、不可替代的一个重要方法是懂业务。向阿里等高级员工懂得如何推出面向用户的产品，这能帮助我们走得更远 2.技术还是我们的立命之本，开始这2年也是需要快速沉淀吸收好技术能力 需要一进去就明确如何发展技术！! 一边做业务一边熟悉业务！! 后续面试 1.二面一般会注重编程能力、编程思维、编程习惯。技术会问得比较深！ 2.三面后端总监面一般会问算法、计算机网络等等知识","link":"/2021/09/22/%E4%B8%AA%E4%BA%BA%E6%94%B6%E8%8E%B7/%E8%85%BE%E8%AE%AF%E4%BA%91%E6%99%BA%E9%9D%A2%E8%AF%95%E6%94%B6%E8%8E%B7/"},{"title":"手写一个webpack","text":"1.实现思路2.实现代码目录结构 add.js1export default (a,b) =&gt; {return a + b} index.js12import add from './add.js'console.log(add(1,2)) webpack.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475const fs = require(&quot;fs&quot;)const path = require(&quot;path&quot;)const parser = require(&quot;@babel/parser&quot;)const traverse = require(&quot;@babel/traverse&quot;).defaultconst babel = require(&quot;@babel/core&quot;)function getModuleInfo(file) { const body = fs.readFileSync(file,&quot;utf-8&quot;) const ast = parser.parse(body, { sourceType: &quot;module&quot; }) const deps = {} traverse(ast,{ ImportDeclaration({node}) { const dirname = path.dirname(file) const abspath = &quot;./&quot; + path.join(dirname,node.source.value) console.log('absPath:',dirname,node.source.value) deps[node.source.value] = abspath } }) const {code} = babel.transformFromAst(ast, null , { presets:[&quot;@babel/preset-env&quot;] }) const moduleInfo = {file,deps,code} return moduleInfo}function parseModules(file) { const entry = getModuleInfo(file) const temp = [entry] const depsGraph = {} getDeps(temp,entry) temp.forEach((moduleInfo) =&gt; { depsGraph[moduleInfo.file] = { deps: moduleInfo.deps, code: moduleInfo.code } }) return depsGraph}function getDeps(temp, { deps }){ Object.keys(deps).forEach((key) =&gt; { const child = getModuleInfo(deps[key]) temp.push(child) getDeps(temp,child) })}function bundle(file) { const depsGraph = JSON.stringify(parseModules(file)) return `(function (graph) { function require(file) { function absRequire(relPath) { return require(graph[file].deps[relPath]) } var exports = {}; (function (require,exports,code) { eval(code) })(absRequire,exports,graph[file].code) return exports } require('${file}') })(${depsGraph});`}const content = bundle('./src/index.js')!fs.existsSync(&quot;./dist&quot;) &amp;&amp; fs.mkdirSync(&quot;./dist&quot;);fs.writeFileSync(&quot;./dist/bundle.js&quot;, content);// const info = getModuleInfo(&quot;./src/index.js&quot;)// console.log(&quot;info:&quot;,info)","link":"/2021/10/07/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAwebpack/"},{"title":"webpack多入口文件打包配置解析","text":"本文是我用webpack进行项目构建的实践心得，场景是这样的，项目是大型类cms型，技术选型是vue，只支持chrome，有诸多子功能模块，全部打包在一起的话会有好几MB，所以最佳方式是进行多入口打包。文章包含我探索的过程以及webpack在使用中的一些技巧，希望能给大家带来参考价值。 首先，项目打包策略遵循以下几点原则： 选择合适的打包粒度，生成的单文件大小不要超过500KB 充分利用浏览器的并发请求，同时保证并发数不超过6 尽可能让浏览器命中304，频繁改动的业务代码不要与公共代码打包 避免加载太多用不到的代码，层级较深的页面进行异步加载 基于以上原则，我选择的打包策略如下： 第三方库如vue、jquery、bootstrap打包为一个文件 公共组件如弹窗、菜单等打包为一个文件 工具类、项目通用基类打包为一个文件 各个功能模块打包出自己的入口文件 各功能模块作用一个SPA，子页面进行异步加载 实验环境“devDependencies”: { “@babel/core”: “^7.15.5”, “@babel/preset-env”: “^7.15.6”, “autoprefixer”: “^10.3.7”, “babel-loader”: “^8.2.2”, “clean-webpack-plugin”: “^4.0.0”, “copy-webpack-plugin”: “^9.0.1”, “cross-env”: “^7.0.3”, “css-loader”: “^6.3.0”, “extract-text-webpack-plugin”: “^4.0.0-beta.0”, “happypack”: “^5.0.1”, “html-webpack-plugin”: “^5.3.2”, “less”: “^4.1.2”, “less-loader”: “^10.0.1”, “mini-css-extract-plugin”: “^2.4.1”, “optimize-css-assets-webpack-plugin”: “^6.0.1”, “postcss-loader”: “^6.1.1”, “style-loader”: “^3.3.0”, “uglifyjs-webpack-plugin”: “^2.2.0”, “vue-loader”: “^15.9.8”, “vue-style-loader”: “^4.1.3”, “vue-template-compiler”: “^2.6.14”, “webpack”: “^5.56.1”, “webpack-bundle-analyzer”: “^4.4.2”, “webpack-cli”: “^4.8.0”, “webpack-dev-server”: “^4.3.1”, “webpack-merge”: “^5.8.0” }, “dependencies”: { “@babel/polyfill”: “^7.12.1”, “lodash”: “^4.17.21”, “lodash.union”: “^4.6.0”, “recursive-readdir-sync”: “^1.0.6”, “vue”: “^2.6.14” } 参考文献： webpack解惑：多入口文件打包策略","link":"/2021/10/15/webpack%E5%A4%9A%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"},{"title":"排序算法","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586var sortArray = function(nums) { let result //result = bubbleSort(nums) //result = selectionSort(nums) //result = insertionSort(nums) result = quickSort(nums) return result};function bubbleSort(arr){ let len = arr.length for(let i = 0;i &lt; len;i++){ for(let j =0; j &lt; len - i - 1 ;j++){ if(arr[j] &gt; arr[j+1]){ [arr[j],arr[j+1]] = [arr[j+1],arr[j]] } } } return arr}function selectionSort(arr){ let len = arr.length for(let i = 0 ; i &lt; len ;i++){ let index = i for(let j = i + 1; j &lt; len ;j++){ if(arr[j] &lt; arr[index]){ index = j } } [arr[i],arr[index]] = [arr[index],arr[i]] } return arr}function insertionSort(arr){ let len = arr.length for(let i = 1; i &lt; len;i++){ let temp = arr[i] let j = i -1 while(j &gt;=0&amp;&amp; arr[j] &gt; temp){ arr[j+1] = arr[j] j-- } arr[j+1] = temp } return arr}const utils = { swap(array, a, b) { [array[a], array[b]] = [array[b], array[a]] }, randomNum() { return Math.floor(Math.random() * 100) }, randomArray() { return Array.from(Array(this.randomNum()), _ =&gt; this.randomNum()) }}function partition(array, start, end) { let j = start let index = Math.floor(Math.random()*(end -start + 1) + start) utils.swap(array, index, end) let pivot = array[end] for (let i = start; i &lt;= end; i++) { if (array[i] &lt;= pivot) { utils.swap(array, i, j++) } } return j - 1}function quickSort(array, start = 0, end = array.length -1) { if (end - start &lt; 1) return array let pivotIndex = partition(array, start, end) quickSort(array, start, pivotIndex - 1) quickSort(array, pivotIndex + 1, end) return array}let array = utils.randomArray()console.log(quickSort(array)) 1234567try{ ajaxGet(url, (error, response) =&gt; { response.data.children = 1; // 可能有异常期望被捕获 });} catch(e){ console.log('failed to get response children'); }","link":"/2021/10/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"前端","slug":"前端","link":"/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"方法论","slug":"方法论","link":"/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"跨域","slug":"跨域","link":"/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"CentOs7","slug":"CentOs7","link":"/tags/CentOs7/"},{"name":"shadowsocks","slug":"shadowsocks","link":"/tags/shadowsocks/"},{"name":"前端工程化","slug":"前端工程化","link":"/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"qiankun","slug":"qiankun","link":"/tags/qiankun/"},{"name":"书法","slug":"书法","link":"/tags/%E4%B9%A6%E6%B3%95/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计算机网络原理","slug":"计算机网络原理","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"数据结构与算法","slug":"数据结构与算法","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","link":"/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"方法论","slug":"方法论","link":"/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/"}]}